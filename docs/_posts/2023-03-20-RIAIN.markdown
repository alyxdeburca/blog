---
layout: post
title:  "Riain"
categories: technology vintage-computing
published: true
---


# NOTE: This project requires the matplotlib, time, and random libraries to function correctly. These libraries can be installed by using _py -m pip install matplotlib._

#

# Investigation and research:

_What is a game?_

-A game is a structured form of play, usually undertaken for entertainment or fun and sometimes used as an educational tool. Many games are also considered to be work or art. Games are sometimes played purely for enjoyment.

Below are some ideas I had considered during my investigation:

- Snakes and ladders
- Battle ships
- Chess
- Checkers
- Guess who
- Text based adventure games.

_What my game will do:_

My game will an abstracted version of X's and O's. I used abstraction because I wanted to keep the core aspects of the game while making the game easier to understand. I did this by allowing the user to type in the position of the cell they want to select instead of using a mouse. In addition, I use the players initials rather than a full name to keep track of the score.

X and O game implementations that I already know exist:

1. G ![](RackMultipart20230320-1-k44yc3_html_1c91d4077c85d9e2.png) oogle implementation of the game

This uses the mouse as an input source, but it doesn't save player name to keep track of a score board.

1. playtictactoe.org

T ![](RackMultipart20230320-1-k44yc3_html_ef7c0bbd7123c741.png) he game this also used the mouse as an input source. It does however track the current score during the session, but it doesn't ask for a name to keep track of the score on a leaderboard.

Design

My game is designed to meet the objectives set out in the Leaving Certificate Computer Science Coursework Project Brief. The game is designed to be played on a desktop computer running Windows10 or Windows11. The game was built to run in the Terminal or Command Line. I used ASCII Art to allow users play a 2D game using python. The design of the game is based on a 3 X 3 grid.

The game is turn-based which means:

- Player 1 goes first followed by Player 2,
- Player 1 is always X and Player 2 is always O,
- The players pick a number between 1 and 9,
- Each number (1 â€“ 9) corresponds to a cell position.

The game menu provides 5 options comprising 3 game modes and 2 statistics options

  1. Single player vs the computer
  2. Multiplayer - (Currently Player1 V Player2)
  3. Simulation - (Computer (Bot) V Computer)
  4. Bot statistics
  5. Player statistics.

Once the game starts you will be presented with a blank board. Beside the board is a Legend (or Map) so you know which number corresponds to each cell.

- For single player, you will be asked for your initials to keep track of your score. You will always be X and the Bot will always be O. X will always move first and then O will move.
- For multiplayer, my game asks both players to input their initials; this is to keep track of their score. Player one will always be X and player 2 will always be O. X will always move first than O will move.
- In simulation mode it's the Bot V the Bot, so it doesn't need any user input - except for the number of simulations the user wishes to run.

The game was designed to be as simple as possible to use. I have done this by having a legend or map beside the board, so the player knows which cell corresponds to each number. By way of validation I will keep asking for input if they enter a number outside of the range or if they select an already used cell.

My target audience is children that play at home with family members or friends, its designed to give a gaming experience in a safe environment removing any concerns about child welfare associated with online gaming. For this reason, I didn't add internet connectivity. This ensures that they can only play with people in the house and cannot connect with anyone outside of this safe environment.

![](RackMultipart20230320-1-k44yc3_html_fa56f9635429b2dc.png)

1. Implementation & planning (around 500 words):

![](RackMultipart20230320-1-k44yc3_html_2269befebef5b2a1.png)

I used an iterative approach to manage my software development project. I used an agile software development methodology to aid in this.

The timeline for my project is as follows:

**Week 1** : During Week 1, I researched some simple games as outlined in the Introduction. I also researched python packages useful for game development. This helped me learn more about the topic of games and game design. I used this information and the information I already knew through CoderDojo to help me. I looked at different games and once I decided on the game of Tic-tac-toe, I researched and looked at different implementations of the game.

**Weeks 2 - 4:** At this point, I had finished my research and started to plan on how the game would be designed and built. I did this by making clear and easy to follow flow chart. I decided to do this because I wanted to avoid problems such as scope creep associated with insufficient design and planning. I also laid out a rough plan for each week , this was to help me stay on track timewise.

**Weeks 5 - 6:** At this stage, I concentrated on getting a simple version of the game working with just Player1 V Player2 and saving this data to a file. This data-file holds all the moves made in the game, the winner's initials and the loser's initials. I started by drawing out the board. I did this by making a function which drew out the board using ASCII Art. This function gets the value for the cell from a dictionary. When the game starts, the dictionary have all blank values. I then have a main game function which has all the game logic inside of it. This includes making sure the player enters a valid input and checking after every move too see if a player has won. By the end of Week 6, I achieved my objective by having a simple working version of the game.

**Weeks 7 - 8:** Since I wrote all my game logic code in functions, it was easy to adapt my code for a Bot to play against the human player. I did this by using the random import in python which allows me to get a random number between 1 and 9. I then make sure that it's not already in use. If that cell is already used, it will generate a different random number.

**Week 9:** I adapted my code for Bot vs Bot and instead of getting player input I get a second random number between 1 and 9 again making sure it points to an empty cell.

**Weeks 10 - 11:** I did lots of testing during these two weeks. I did both black- and white-box testing. From my experience with testing this project I think that black-box testing is better because during the testing I found a lot more issues that I wouldn't have found if I used white-box testing. Please refer to the testing section below.

**Week 12:** This week was spent writing my report and checking and adding my references to the report. I also had to make a few last minutes changes to the report because I discovered that I was over the total word count, I fixed this by rephrasing a few areas. Finally, I converted my reported into HTML to provide the requested web-based format for my final submission.

Testing ( around 350 words):

I carried out rigorous testing to make sure my game works. I started with white box testing before deciding to take a more systematic approach to testing. I took note of all the different inputs a user could select, and I also took note of what type of data should go into each one. Then I decided to input the wrong types of data, and observe my results. If the wrong data was accepted, then it would generate an error and I would have to fix it. If my code caught the issue and re-asked for input, then I knew that my code worked. I had many iterations of this process until all my code was working.

While testing, I discovered that it would accept a number outside of the 1-9 range but that this would cause an error. I also found out that I could give it a string input and when this happened the game would once again error out. I also discovered that I could give it a float value and when this happened it would also result in error. Any of these errors would cause the game to crash; not a satisfactory situation. To correct these issues, I made a function which validates my input before accepting it. The function will keep asking for input if it's not an integer between 1 and 9. It will only return the input If the input meets the criteria.

For black box testing I gave it to my younger sister and asked her to play a few games. I did this because she is of similar age to my target audience. From this, I discovered that she could choose cells that were already chosen, this also meant when she got to 9 moves the game would automatically end even if it all of the cells had not been filled. To solve this error, when I get my input, I do a check with the dictionary holding all the positions to see if the cell chosen is already occupied. If it is, the game prompts for re-input. By fixing the first problem, the second problem also got fixed because if I get 9 valid inputs as moves then I can be sure that all the cells are used up. And once all of the 9 cells are filled, we either have a Winner or a Draw

Test table for when asked to pick a cell:

| **Test Id** | **Input** | **Accept input Y/N** | **Pass or Fail** |
| --- | --- | --- | --- |
| Test.1 | 1 | Y | Pass |
| Test.2 | 10 | N | pass |
| Test.3 | 'hello' | N | pass |
| Test.4 | ['1','2','3'] | N | pass |
| Test.5 | 4.2 | N | Pass |
| Test.6 | True | N | pass |

Test table when asked to choose a name:

| **Test id** | **Input** | **Accepted input Y/N** | **Pass or fail** |
| --- | --- | --- | --- |
| Test.7 | 'hii' | N | Pass |
| Test.8 | 8.2 | N | Pass |
| Test.9 | 77 | Y | Pass |
| Test.10 | 'Bo' | N | pass |
| Test.11 | ['1','5','hi','88'] | N | pass |
| Test.12 | 8 | N | pass |

Evaluation (around 300 words):

I think that overall, the project went well, and I am satisfied with my implementation of the game. Looking at the project brief, I believe that I have achieved all of the Basic and Advanced requirements of the project. I came across many setbacks while creating the project, but I used the skills I learned through my studies and CoderDoJo to work out these issues . I was familiar with basic Python prior the project. I also had knowledge of HTML and CSS from attending and mentoring in CoderDoJo.

While creating this project I learned a lot. I learned how to think around a problem. I learned about testing methodologies in an agile environment. My Python skills have also developed to include the basics of Object-oriented programming in python.

**Future improvements**

- If I had more time, I would add more functionality such as the user being able to choose their preferred character (X or O).
- I would also add different levels such as Easy, Medium and Master, when playing against the Bot. This would also allow me to broaden my target audience to include younger children and even adults.

**What I Could improve on**

- I could definitely have managed my time better. While I feel I put a lot of work into the design and planning stage, the project could have benefitted from a more granular or detailed plan. Of course, given the time constraints, I did the best I could.
- There were some parts of the game that took longer than they should have, for example making the simulation play and the single player against the Bot. I chalk this wasted time up to my inexperience with the programming language.
- If I was doing it now, I would have been able to do it much quicker. This would also allow me to create, test and implement more features.

**What if:**

- My what if question:
  - Does the player who has the first move have an advantage in the outcome of the game ?
    - To do check this I ran a simulation 100 times and graphed the results. From this, I found out that the player that moves first does in fact have the advantage. From my data I discovered that if both players move randomly the player who moves first has a 70% chance of winning.

![](RackMultipart20230320-1-k44yc3_html_daba387b75610a2c.png)

![](RackMultipart20230320-1-k44yc3_html_48563a22b0010cfa.png)
